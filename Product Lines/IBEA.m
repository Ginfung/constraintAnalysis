% get the result from IBEA optimizer
% modified from Sayyad, Abdel Salam, Tim Menzies, and Hany Ammar. "On the value of user preferences in search-based software engineering: A case study in software product lines." Software engineering (ICSE), 2013 35th international conference on. IEEE, 2013.

clear all

global totalFeatureNum; %set up the total number of features
global totalLeavesNum;  %set up the total number of leaves, which should be determined
global cost;
global usedbefore;
global defects;

%% set up the SXFM feature model attributes
totalFeatureNum = 43;
totalLeavesNum = 28;
cost = rand(1,totalFeatureNum)*10+5; % cost between 5.0 and 15.0
usedbefore = randi([0 1],1,totalFeatureNum); %usedbefore is a binary random variable
defects = rand(1,totalFeatureNum) * 10; %defects between 0 and 10
for i = 1:totalFeatureNum
    if usedbefore(i) == 0
        defects(i) = 0;
    end
end

%% set up IBEA parameters
Problem = @SXFM_web_portal; %problems can be generated by another automatic tool written in Java (see SXFM_Parser)
alpha = 100; % population size
gen_max = 500; % maximum generation
D = totalLeavesNum; % decision space dimension
ObjectiveDimension = 5; % objective(goal) space dimension % all goals should be minimized
k = 1; % fitness scaling factor. Defaultly 1.


%% step 1: Initializaiton
parent = randi([0 1],alpha,D); %initialize in the binary space
f = zeros(alpha,ObjectiveDimension);

evoluationRecord = zeros(ObjectiveDimension,gen_max);

%get the objective for initial parent
for i = 1:alpha
    f(i,:) = Problem(parent(i,:),D);
end

trial = zeros(1,D);
trial_objective = zeros(1,ObjectiveDimension);

count = 1;
while (count <= gen_max)
    for i = 1:length(f)
        %get distinct a,b,c
        rev = randperm(length(f));
        a = rev(1);
        b = rev(2);
        c = rev(3);
        
        %% Mutation begin
        %modified from the idea of continuous differential evaluation
        %!!ALERT: DO NOT take the "amount" of dominance into conderation!!
        for k = 1:D
            if (rand()<CR || k == D)
                if rand() > F
                    trial(k) = parent(a,k);
                else
                    if rand()>0.5
                        trial(k) = parent(b,k);
                    else
                        trial(k) = parent(c,k);
                    end
                end
            else
                trial(k) = parent(i,k);
            end
        end
        %%
        trial_objective = Problem(trial,D);
        
        if testDominate(trial_objective,f(i,:),ObjectiveDimension)
            parent(i,:) = trial;
            f(i,:) = trial_objective;
        elseif (~testDominate(f(i,:),trial_objective,ObjectiveDimension)) %indifferent. add to NP
            parent = [parent;trial];
            f = [f;trial_objective];
        end
    end
    if(length(f) > alpha) %pruning s.t. size = 4NP-->NP
        rank = fastNonDominatedSort(f,length(f),ObjectiveDimension);
        parent2 = zeros(alpha,D);
        f2 = zeros(alpha,ObjectiveDimension);
        i = 1;
        renew_count = 0;
        while 1
            qqq = find(rank(:)==i);
            if renew_count+length(qqq) > alpha %basing on the distance
                needC = alpha-renew_count;
                pool_f = f(qqq,:);
                pool_p = parent(qqq,:);
                I = crowdDistanceAssignment(pool_f,length(qqq),ObjectiveDimension);
                pool_f = [pool_f,I'];
                pool_p = [pool_p,I'];
                sortrows(pool_f,-(ObjectiveDimension+1));
                f2(renew_count+1:alpha,:) = pool_f(1:needC,1:ObjectiveDimension);
                sortrows(pool_p,-(D+1));
                parent2(renew_count+1:alpha,:) = pool_p(1:needC,1:D);
                f = f2;
                parent = parent2;
                break;
            end
            parent2(renew_count+1:renew_count+length(qqq),:) = parent(qqq,:);
            f2(renew_count+1:renew_count+length(qqq),:) = f(qqq,:);
            renew_count = renew_count+length(qqq);
            i = i+1;
        end
    end
    for i = 1:alpha
        f(i,:) = Problem(parent(i,:),D);
    end
    for i = 1:ObjectiveDimension
        evoluationRecord(i,count) = mean(f(:,i));
    end
    count  = count + 1
end

%% draw the evaluation record
% Map to the unit interval
evoluationRecord = evoluationRecord';
for i = 1 : ObjectiveDimension
    a = max(evoluationRecord(:,i));
    b = min(evoluationRecord(:,i));
    delta = a - b;
    evoluationRecord(:,i) = (evoluationRecord(:,i)-b)/delta;
end
plot(evoluationRecord);figure(gcf);
%%


